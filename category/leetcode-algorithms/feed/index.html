<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
 xmlns:content="http://purl.org/rss/1.0/modules/content/"
 xmlns:wfw="http://wellformedweb.org/CommentAPI/"
 xmlns:dc="http://purl.org/dc/elements/1.1/"
 xmlns:atom="http://www.w3.org/2005/Atom"
 xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
 xmlns:slash="http://purl.org/rss/1.0/modules/slash/" 
 xmlns:georss="http://www.georss.org/georss"
 xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
 > <channel><title>Leetcode Algorithms &#8211; Wonderful Tech</title> <atom:link href="http://www.showsql.com/category/leetcode-algorithms/feed/" rel="self" type="application/rss+xml" /><link>https://www.showsql.com/</link> <description>Learning Always</description> <lastBuildDate>Sat, 14 Mar 2020 14:00:50 +0000</lastBuildDate> <language>en-US</language> <sy:updatePeriod> hourly </sy:updatePeriod> <sy:updateFrequency> 1 </sy:updateFrequency> <generator>https://wordpress.org/?v=5.5.1</generator> <image> <url>http://www.showsql.com/wp-content/uploads/2019/09/cropped-logo-1-32x32.jpg</url><title>Leetcode Algorithms &#8211; Wonderful Tech</title><link>https://www.showsql.com/</link> <width>32</width> <height>32</height> </image> <site xmlns="com-wordpress:feed-additions:1">168814421</site> <item><title>leetcode6  Z 字形变换 ZigZag Conversion 精选题解</title><link>http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-best-solution-2/</link> <dc:creator><![CDATA[jasonpeng]]></dc:creator> <pubDate>Sat, 14 Mar 2020 14:00:24 +0000</pubDate> <category><![CDATA[Leetcode Algorithms]]></category> <category><![CDATA[算法与数据结构]]></category> <guid isPermaLink="false">http://www.showsql.com/?p=14625</guid> <description><![CDATA[<p>算法: 这个 Z 字型其实是这样的： 对于前面的 3 行的 示例1 , 它的字符数分布是这样的： 对于前面的 4 行的 示例2 , 它的字符数分布是这样的： 那么对于 n 行的字符数分布是这样的： 如上图所示，我们可以发现： 1.当前行 curRow 为 0 或 n-1 时，箭头发生反向转折。 方法一： 从左到右按箭头方向迭代 s ，将每个字符添加到合适的行。之后从上到下遍历行即可。 我们假定 n=numRows : 代码如下 class Solution { public: string convert(string s, int numRows) { &#38;lt;pre&#38;gt;&#38;lt;code&#38;gt; if (numRows == 1) return s; vector&#38;lt;string&#38;gt; rows(min(numRows, int(s.size()))); [&#8230;]</p><p>The post <a href="http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-best-solution-2/" target="_blank">leetcode6  Z 字形变换 ZigZag Conversion 精选题解</a> first appeared on <a href="http://www.showsql.com/" target="_blank">Wonderful Tech</a>.</p>]]></description> <post-id xmlns="com-wordpress:feed-additions:1">14625</post-id> </item> <item><title>leetcode6  Z 字形变换 ZigZag Conversion 精选题解</title><link>http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-best-solution/</link> <dc:creator><![CDATA[jasonpeng]]></dc:creator> <pubDate>Sat, 14 Mar 2020 13:57:31 +0000</pubDate> <category><![CDATA[Leetcode Algorithms]]></category> <category><![CDATA[算法与数据结构]]></category> <guid isPermaLink="false">http://www.showsql.com/?p=14623</guid> <description><![CDATA[<p>解题思路： 题目理解： 字符串 s 是以 ZZ 字形为顺序存储的字符串，目标是按行打印。 设 numRows 行字符串分别为 s_1s 1 ​ , s_2s 2 ​ ,..., s_ns n ​ ，则容易发现：按顺序遍历字符串 s 时，每个字符 c 在 ZZ 字形中对应的 行索引 先从 s_1s 1 ​ 增大至 s_ns n ​ ，再从 s_ns n ​ 减小至 s_1s 1 ​ …… 如此反复。 因此，解决方案为：模拟这个行索引的变化，在遍历 s 中把每个字符填到正确的行 res[i] 。 算法流程： 按顺序遍历字符串 s； [&#8230;]</p><p>The post <a href="http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-best-solution/" target="_blank">leetcode6  Z 字形变换 ZigZag Conversion 精选题解</a> first appeared on <a href="http://www.showsql.com/" target="_blank">Wonderful Tech</a>.</p>]]></description> <post-id xmlns="com-wordpress:feed-additions:1">14623</post-id> </item> <item><title>leetcode6  Z 字形变换 ZigZag Conversion 官方题解</title><link>http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-official-solution/</link> <dc:creator><![CDATA[jasonpeng]]></dc:creator> <pubDate>Sat, 14 Mar 2020 13:50:13 +0000</pubDate> <category><![CDATA[Leetcode Algorithms]]></category> <category><![CDATA[算法与数据结构]]></category> <guid isPermaLink="false">http://www.showsql.com/?p=14620</guid> <description><![CDATA[<p>方法一：按行排序 思路 通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。 算法 我们可以使用 \text{min}( \text{numRows}, \text{len}(s))min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。 从左到右迭代 ss，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。 只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。 class Solution { public: string convert(string s, int numRows) { &#38;lt;pre&#38;gt;&#38;lt;code&#38;gt; if (numRows == 1) return s; vector&#38;lt;string&#38;gt; rows(min(numRows, int(s.size()))); int curRow = 0; bool goingDown = false; for (char c : s) { rows[curRow] += c; if (curRow [&#8230;]</p><p>The post <a href="http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-official-solution/" target="_blank">leetcode6  Z 字形变换 ZigZag Conversion 官方题解</a> first appeared on <a href="http://www.showsql.com/" target="_blank">Wonderful Tech</a>.</p>]]></description> <post-id xmlns="com-wordpress:feed-additions:1">14620</post-id> </item> <item><title>leetcode5 最长回文子串 Longest Palindromic Substring 精选题解</title><link>http://www.showsql.com/2020/03/14/leetcode5-longest-palindromic-substring-best-solution-3/</link> <dc:creator><![CDATA[jasonpeng]]></dc:creator> <pubDate>Sat, 14 Mar 2020 13:46:30 +0000</pubDate> <category><![CDATA[Leetcode Algorithms]]></category> <category><![CDATA[算法与数据结构]]></category> <guid isPermaLink="false">http://www.showsql.com/?p=14617</guid> <description><![CDATA[<p>算法: 什么叫回文串？ 如果一个字符串正着读和反着读是一样的，那它就是回文串。 中心扩展算法 我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n - 1 个这样的中心。 你可能会问，为什么会是 2n - 1 个，而不是 n 个中心？ 因为回文的中心要区分单双。 假如回文的中心为 双数，例如 abba，那么可以划分为 ab bb ba，对于n长度的字符串，这样的划分有 n-1 种。 假为回文的中心为 单数，例如 abcd, 那么可以划分为 a b c d， 对于n长度的字符串，这样的划分有 n 种。 对于 n 长度的字符串，我们其实不知道它的回文串中心倒底是单数还是双数，所以我们要对这两种情况都做遍历，也就是 n+(n-1) = 2n - 1，所以时间复杂度为 O(n)。 当中心确定后，我们要围绕这个中心来扩展回文，那么最长的回文可能是整个字符串，所以时间复杂度为 O(n)。 所以总时间复杂度为 O(n^2) 代码如下： string longestPalindrome(string s) { if [&#8230;]</p><p>The post <a href="http://www.showsql.com/2020/03/14/leetcode5-longest-palindromic-substring-best-solution-3/" target="_blank">leetcode5 最长回文子串 Longest Palindromic Substring 精选题解</a> first appeared on <a href="http://www.showsql.com/" target="_blank">Wonderful Tech</a>.</p>]]></description> <post-id xmlns="com-wordpress:feed-additions:1">14617</post-id> </item> <item><title>leetcode5 最长回文子串 Longest Palindromic Substring 精选题解</title><link>http://www.showsql.com/2020/03/14/leetcode5-longest-palindromic-substring-best-solution-2/</link> <dc:creator><![CDATA[jasonpeng]]></dc:creator> <pubDate>Sat, 14 Mar 2020 13:41:41 +0000</pubDate> <category><![CDATA[Leetcode Algorithms]]></category> <category><![CDATA[算法与数据结构]]></category> <guid isPermaLink="false">http://www.showsql.com/?p=14615</guid> <description><![CDATA[<p>解法 1：暴力法 菜鸡的我第一想法只能想到暴力法，遍历各种可能结果。 class Solution { public: string longestPalindrome(string s) { string res=&#38;quot;&#38;quot;;//存放结果 string temp=&#38;quot;&#38;quot;;//存放子串 for(int i=0;i&#38;lt;s.length();i++) { for(int j=i;j&#38;lt;s.length();j++) { temp=temp+s[j]; string tem=temp;//tem存放子串反转结果 std::reverse(tem.begin(),tem.end());//反转 if(temp==tem) res=res.length()&#38;gt;temp.length()?res:temp; } temp=&#38;quot;&#38;quot;; } return res; } }; &#38;lt;pre&#38;gt;&#38;lt;code&#38;gt;该办法效率太低，所以力扣测试用例只能通过46个，后续的会超出时间限制 # 解法 2： 将字符串 s 反转得到字符串 rev，再求他们的最长公共子串，再判断该最长公共子串是否就是我们要找的最长回文子串。 ```C++ class Solution { public: string longestPalindrome(string s) { if(s.length()==1) return s;//大小为1的字符串必为回文串 string [&#8230;]</p><p>The post <a href="http://www.showsql.com/2020/03/14/leetcode5-longest-palindromic-substring-best-solution-2/" target="_blank">leetcode5 最长回文子串 Longest Palindromic Substring 精选题解</a> first appeared on <a href="http://www.showsql.com/" target="_blank">Wonderful Tech</a>.</p>]]></description> <post-id xmlns="com-wordpress:feed-additions:1">14615</post-id> </item> </channel> </rss>