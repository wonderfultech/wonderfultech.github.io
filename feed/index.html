<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
 xmlns:content="http://purl.org/rss/1.0/modules/content/"
 xmlns:wfw="http://wellformedweb.org/CommentAPI/"
 xmlns:dc="http://purl.org/dc/elements/1.1/"
 xmlns:atom="http://www.w3.org/2005/Atom"
 xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
 xmlns:slash="http://purl.org/rss/1.0/modules/slash/" 
 xmlns:georss="http://www.georss.org/georss"
 xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
 > <channel><title>Wonderful Tech</title> <atom:link href="http://www.showsql.com/feed/" rel="self" type="application/rss+xml" /><link>https://www.showsql.com/</link> <description>Learning Always</description> <lastBuildDate>Sun, 07 Jun 2020 12:16:09 +0000</lastBuildDate> <language>en-US</language> <sy:updatePeriod> hourly </sy:updatePeriod> <sy:updateFrequency> 1 </sy:updateFrequency> <generator>https://wordpress.org/?v=5.5.1</generator> <image> <url>http://www.showsql.com/wp-content/uploads/2019/09/cropped-logo-1-32x32.jpg</url><title>Wonderful Tech</title><link>https://www.showsql.com/</link> <width>32</width> <height>32</height> </image> <site xmlns="com-wordpress:feed-additions:1">168814421</site> <item><title>MySQL 8.0 Buffer pool 结构</title><link>http://www.showsql.com/2020/06/07/mysql-8-0-buffer-pool-structure/</link> <dc:creator><![CDATA[jasonpeng]]></dc:creator> <pubDate>Sun, 07 Jun 2020 12:15:47 +0000</pubDate> <category><![CDATA[MySQL]]></category> <guid isPermaLink="false">http://www.showsql.com/?p=14639</guid> <description><![CDATA[<p>Buffer Pool 简介 CPU通过总线直接访问内存。CPU不能直接访问或修改数据库文件。 在操作数据前，数据必须从数据库文件加载到内存中。 每次要操作数据时，都从数据库文件中加载数据，效率低。 因此，在内存中缓存相关的数据，会是一个更好的选择。 Innodb用buffer pool组件解决数据缓存的问题。Innodb中可以有多个buffer pool实例。 page和frame中的数据相同。数据在数据库文件中，就叫page。数据在buffer pool中就叫frame。 每个buffer pool由以下几个组件构成: 一个或多个buffer chunks: chunk中由多个frame（帧，一块内存），其能保存数据。每个帧由独立的控制块。 free list: 未被使用的frame都链在free list。 lru list: 所有保存数据的帧（未被修改或已被修改）都链在lru list。 flush list: 所有保存被修改的数据的帧都链在flush list。在flush list中的frame同样也在lru list中。 page hash表: hash表用于加速在lru list中查找帧。 双写缓冲区double write buffer: 独立于buffer chunk的一块内存，保存将要被刷新到文件中的frame。 Mutexes: 在并发环境中保存上面的各种list。innodb没有直接使用系统提供的mutex（类型pthread），而是单独开发了一套复杂的mutex系统。 页清理线程Page Cleaner Thread: 首先，它将脏frame刷新到double write buffer。用同步模式将这些frame刷新到文件中的专有空间。其次，用异步模式将它们写到数据库文件。 预读Read ahead: 页预读提高读页效率。 Logical Buffer pool 实例结构简图 [&#8230;]</p><p>The post <a href="http://www.showsql.com/2020/06/07/mysql-8-0-buffer-pool-structure/" target="_blank">MySQL 8.0 Buffer pool 结构</a> first appeared on <a href="http://www.showsql.com/" target="_blank">Wonderful Tech</a>.</p>]]></description> <post-id xmlns="com-wordpress:feed-additions:1">14639</post-id> </item> <item><title>MySQL 8.0 Buffer pool</title><link>http://www.showsql.com/2020/06/07/mysql-8-0-buffer-pool/</link> <dc:creator><![CDATA[jasonpeng]]></dc:creator> <pubDate>Sun, 07 Jun 2020 12:10:42 +0000</pubDate> <category><![CDATA[MySQL]]></category> <guid isPermaLink="false">http://www.showsql.com/?p=14631</guid> <description><![CDATA[<p>Buffer Pool Introduction CPU can access the memory with the buss directly. CPU can not access or modify the data directly in the database file. Before manipulating the data, the data must be loaded from the database file into the memory. It is inefficient to reload the data from the database file every time you [&#8230;]</p><p>The post <a href="http://www.showsql.com/2020/06/07/mysql-8-0-buffer-pool/" target="_blank">MySQL 8.0 Buffer pool</a> first appeared on <a href="http://www.showsql.com/" target="_blank">Wonderful Tech</a>.</p>]]></description> <post-id xmlns="com-wordpress:feed-additions:1">14631</post-id> </item> <item><title>leetcode6  Z 字形变换 ZigZag Conversion 精选题解</title><link>http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-best-solution-2/</link> <dc:creator><![CDATA[jasonpeng]]></dc:creator> <pubDate>Sat, 14 Mar 2020 14:00:24 +0000</pubDate> <category><![CDATA[Leetcode Algorithms]]></category> <category><![CDATA[算法与数据结构]]></category> <guid isPermaLink="false">http://www.showsql.com/?p=14625</guid> <description><![CDATA[<p>算法: 这个 Z 字型其实是这样的： 对于前面的 3 行的 示例1 , 它的字符数分布是这样的： 对于前面的 4 行的 示例2 , 它的字符数分布是这样的： 那么对于 n 行的字符数分布是这样的： 如上图所示，我们可以发现： 1.当前行 curRow 为 0 或 n-1 时，箭头发生反向转折。 方法一： 从左到右按箭头方向迭代 s ，将每个字符添加到合适的行。之后从上到下遍历行即可。 我们假定 n=numRows : 代码如下 class Solution { public: string convert(string s, int numRows) { &#38;lt;pre&#38;gt;&#38;lt;code&#38;gt; if (numRows == 1) return s; vector&#38;lt;string&#38;gt; rows(min(numRows, int(s.size()))); [&#8230;]</p><p>The post <a href="http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-best-solution-2/" target="_blank">leetcode6  Z 字形变换 ZigZag Conversion 精选题解</a> first appeared on <a href="http://www.showsql.com/" target="_blank">Wonderful Tech</a>.</p>]]></description> <post-id xmlns="com-wordpress:feed-additions:1">14625</post-id> </item> <item><title>leetcode6  Z 字形变换 ZigZag Conversion 精选题解</title><link>http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-best-solution/</link> <dc:creator><![CDATA[jasonpeng]]></dc:creator> <pubDate>Sat, 14 Mar 2020 13:57:31 +0000</pubDate> <category><![CDATA[Leetcode Algorithms]]></category> <category><![CDATA[算法与数据结构]]></category> <guid isPermaLink="false">http://www.showsql.com/?p=14623</guid> <description><![CDATA[<p>解题思路： 题目理解： 字符串 s 是以 ZZ 字形为顺序存储的字符串，目标是按行打印。 设 numRows 行字符串分别为 s_1s 1 ​ , s_2s 2 ​ ,..., s_ns n ​ ，则容易发现：按顺序遍历字符串 s 时，每个字符 c 在 ZZ 字形中对应的 行索引 先从 s_1s 1 ​ 增大至 s_ns n ​ ，再从 s_ns n ​ 减小至 s_1s 1 ​ …… 如此反复。 因此，解决方案为：模拟这个行索引的变化，在遍历 s 中把每个字符填到正确的行 res[i] 。 算法流程： 按顺序遍历字符串 s； [&#8230;]</p><p>The post <a href="http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-best-solution/" target="_blank">leetcode6  Z 字形变换 ZigZag Conversion 精选题解</a> first appeared on <a href="http://www.showsql.com/" target="_blank">Wonderful Tech</a>.</p>]]></description> <post-id xmlns="com-wordpress:feed-additions:1">14623</post-id> </item> <item><title>leetcode6  Z 字形变换 ZigZag Conversion 官方题解</title><link>http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-official-solution/</link> <dc:creator><![CDATA[jasonpeng]]></dc:creator> <pubDate>Sat, 14 Mar 2020 13:50:13 +0000</pubDate> <category><![CDATA[Leetcode Algorithms]]></category> <category><![CDATA[算法与数据结构]]></category> <guid isPermaLink="false">http://www.showsql.com/?p=14620</guid> <description><![CDATA[<p>方法一：按行排序 思路 通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。 算法 我们可以使用 \text{min}( \text{numRows}, \text{len}(s))min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。 从左到右迭代 ss，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。 只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。 class Solution { public: string convert(string s, int numRows) { &#38;lt;pre&#38;gt;&#38;lt;code&#38;gt; if (numRows == 1) return s; vector&#38;lt;string&#38;gt; rows(min(numRows, int(s.size()))); int curRow = 0; bool goingDown = false; for (char c : s) { rows[curRow] += c; if (curRow [&#8230;]</p><p>The post <a href="http://www.showsql.com/2020/03/14/leetcode6-z-zigzag-conversion-official-solution/" target="_blank">leetcode6  Z 字形变换 ZigZag Conversion 官方题解</a> first appeared on <a href="http://www.showsql.com/" target="_blank">Wonderful Tech</a>.</p>]]></description> <post-id xmlns="com-wordpress:feed-additions:1">14620</post-id> </item> </channel> </rss>